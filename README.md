# üî¢ PUSH_SWAP üî¢

A sorting algorithm project made by Panu Kangas.  
Assignment provided by Hive Helsinki coding school.  
Project is written in C-language on macOS.

<br/>  

# How to use? ü§î

Git clone the push_swap repository. 
Do ```make all``` in the directory to compile my push_swap program. 
Do ```make bonus```in the directory to compile my checker program.
Other Makefile rules:

- ```make clean```--> remove all object files
- ```make fclean```--> remove all object files + executables
- ```make re```--> do fclean + all

<br/>  

# The original assignment üìé

The main idea of push_swap project is quite simple: you have to write a program that arranges random numbers (integers) into ascending order using a strict set of rules and operations.
Rules and operation details are listed in later segments of this Readme.

Initially you have two stacks: Stack A and Stack B.
Stack A is filled with random numbers, Stack B is empty.
In the end, if all went as it should, Stack A should have all of the original numbers in ascending order and Stack B should be empty.

The push_swap program is supposed to analyze numbers of Stack A and then produce a list of operations (the smallest list possible) to do this sorting.  
Eventually the operation list generated by push_swap is compared to a certain "operation count limit". Push_swap project is then graded based on this comparison.  
Info about operation count limits can be found in later segments of this Readme.

<br/>

üèÜ BONUS üèÜ  

The bonus part of this assignment was to write a checker program, that takes the numbers of Stack A as arguments and then waits (reading from standard input) for a list of operations. Finally it should perform these instructions to the Stack A and print "OK" if numbers were sorted after the operation execution.
If not, it should print "KO".  

<br/>

Confused? üòÅ  
Yeah, I was too, when this project started.  
But no worries, read on and things will become clearer.

<br/>

### Rules for push_swap assignment üõë

- Numbers are given to the program as command line arguments.
- First number given is the first number of Stack A, second number given is the second number of Stack A etc.
- Numbers can be given in two formats: one number per argument (```./push_swap 1 2 3```) or all numbers in one argument-string (```./push_swap "1 2 3"```)
- Numbers have to fit in an int variable.
- No duplicate numbers allowed.
- Program should write "Error" if these rules are broken (dupicate number found etc)

<br/>

### Operation count limits üßÆ

Here are the operation count limits for push_swap project's maximum points.   
If push_swap program can do the sorting of Stack A within these limits, the program is awarded with full 100/100 points üòé

| Stack size  | Operation count limit |
| ------------- | ------------- |
| 3 numbers | 3 operations max |
| 5 numbers | 12 operations max (if 8 or less, kudos) |
| 100 numbers | less that 700 operations |
| 500 numbers | less than 5500 operations |  

<br/>

### Operations to do the sorting üìë

You are only allowed to use these operations to sort the numbers in Stack A:

‚ÜïÔ∏è SA (swap a): Swap the first 2 elements of Stack A. Do nothing if there is only one or no elements.  
‚ÜïÔ∏è SB (swap b): Swap the first 2 elements of Stack B. Do nothing if there is only one or no elements.  
‚ÜïÔ∏è SS (swap both): Do sa and sb at the same time. This is counted as one move.  

‚û°Ô∏è PA (push to a): Take the first element of Stack B and put it as the first element of Stack A (moving the former first element of A to the second position of A etc).
  Do nothing if B is empty.  
‚û°Ô∏è PB (push to b): Take the first element of Stack A and put it as the first element of Stack B (moving the former first element of B to second position of B etc).
  Do nothing if A is empty.  

‚§¥Ô∏è RA (rotate a): Move "forwards" all elements of Stack A by 1 (former second element becomes first, former third element becomes second etc). The first element of A becomes the last element of A.  
‚§¥Ô∏è RB (rotate b): Move "forwards" all elements of Stack B by 1 (former second element becomes first, former third element becomes second etc). The first element of B becomes the last element of B.  
‚§¥Ô∏è RR (rotate both): Do ra and rb at the same time. This is counted as one move.  

‚§µÔ∏è RRA (reverse rotate a): Move "backwards" all elements of Stack A by 1 (former first element becomes second, former second element becomes third etc).
  The last element of A becomes the first element of A.  
‚§µÔ∏è RRB (reverse rotate b): Move "backwards" all elements of Stack B by 1 (former first element becomes second, former second element becomes third etc).
  The last element of B becomes the first element of B.  
‚§µÔ∏è RRR (reverse rotate both): Do rra and rrb at the same time. This is counted as one move.  

<br/>

### General rules of Hive (that affect the code) üìò

1Ô∏è‚É£ Hive students must follow a "Norm" when it comes to writing code. Norm determines certain rules for code layout. Two examples from the Norm:
  --> One function can only have a maximum of 25 lines of code.  
  --> One .c file can only have up to 5 functions.
  
  Because of these rules I have made some "not so convenient" tricks with my code implementation (to avoid the 25 line limit). Sorry about that üôà
  Also, some of my functions are placed a bit "unlogically", because of the 5 function per file -rule. I made some small comments in the code to make program flow clearer.
  
2Ô∏è‚É£ Almost all of the regular C library functions are forbidden (printf, strlen etc).
  --> This is why my code utilizes Libft-library which is written by me. It consists of my own versions of these must-have functions (ft_printf, ft_strlen etc)  

<br/>



# How to solve this thing then ‚ùì‚ùó

I feel like this is a project that requires more logical problem solving than complicated coding tricks. ü§î  

Especially the push_swap program requires mostly if/else comparing of numbers and then executing the operations given accordingly.  
One has to be careful for the error handling though, because it's easy to miss some kind of unwanted input or forget to free arrays after an error occurs... üò≥  
The bonus part needed a bit more coding knowledge (on how to get the operations given from STDIN).

I don't wanna explain the whole logic behind my sorting algorithm, because... well, mostly because I don't wanna write hundreds of lines in this Readme üòÅ  
But here are few bullet points about my algo:

### What ideas/sorting algorithms I used?

1Ô∏è‚É£ I used an idea that follows the principles of <ins>insertion sort</ins> to do the actual final sorting.
  An example:  
  
  If I had a number X as the first element of Stack B, and I wanted to sort that into Stack A, I'd used my *sort_b_to_a* -function.
  *Sort_b_to_a* first finds the correct position for the number X, then rotates stack A so that when i use PA operation, the number X is moved to it's correct position.
  "Correct position" in this case means (if Stack A numbers are in order) a position where the number after X is greater than X and the number before X is smaller than X.
  This is because eventually we want the numbers of Stack A to be in ascending order.  
  
  If we just loop this idea and finally rotate Stack A so that the smallest number is in the first position, we should get us a nicely sorted stack üòé

2Ô∏è‚É£ 

### The steps of sorting


